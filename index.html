<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FPS Scene with Knife, Enemies & Health</title>
<style>
  body { margin: 0; overflow: hidden; background: black; cursor: none; }
  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px; height: 20px;
    margin-left: -10px; margin-top: -10px;
    pointer-events: none;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: white;
  }
  #crosshair:before { width: 2px; height: 20px; left: 9px; top: 0; }
  #crosshair:after { width: 20px; height: 2px; top: 9px; left: 0; }
  #hotbar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 10;
  }
  .slot {
    width: 50px; height: 50px;
    background: rgba(50,50,50,0.7);
    border: 2px solid #fff;
    display: flex; align-items: center; justify-content: center;
    font-family: sans-serif;
    font-size: 14px; color: #fff;
    position: relative;
    cursor: pointer;
  }
  .slot.selected { border-color: yellow; }
  .slot-label {
    position: absolute;
    top: -20px; width: 100%;
    text-align: center;
    font-family: sans-serif; font-size: 14px;
    color: white;
  }
  #healthBarContainer {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 220px;
    height: 25px;
    background: #555;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: 0 0 10px #000;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 5px;
  }
  #healthBar {
    height: 100%;
    width: 100%;
    background: #0f0;
    transition: width 0.3s ease, background-color 0.3s ease;
    flex-grow: 1;
    border-radius: 3px;
  }
  #quickPlayBtn {
    position: fixed; top: 20px; right: 20px;
    padding: 10px 20px; background: #222; color: #fff; border: none; cursor: pointer; z-index: 20;
  }
</style>
</head>
<body>
<button id="quickPlayBtn">Enable Local Multiplayer</button>
<div id="crosshair"></div>
<div id="hotbar"></div>
<div id="healthBarContainer">
  <div id="healthBar"></div>
  <div id="healthNumber">100</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

<script>
let scene, camera, renderer, controls;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let canJump = false;
let isCrouching = false;
const gravity = 30;

const hotbar = document.getElementById('hotbar');
const healthBar = document.getElementById('healthBar');
const healthNumber = document.getElementById('healthNumber');
const quickPlayBtn = document.getElementById('quickPlayBtn');

const slots = [
  { name: 'Knife', item: 'ðŸ”ª' },
  { name: 'Empty', item: '' },
  { name: 'Empty', item: '' },
  { name: 'Empty', item: '' },
  { name: 'Empty', item: '' },
];
let selectedSlot = 0;

function createHotbar() {
  hotbar.innerHTML = '';
  for (let i=0; i<slots.length; i++) {
    const slotDiv = document.createElement('div');
    slotDiv.className = 'slot' + (i === selectedSlot ? ' selected' : '');
    slotDiv.innerHTML = slots[i].item;
    slotDiv.onclick = () => { selectSlot(i); };
    const label = document.createElement('div');
    label.className = 'slot-label';
    label.innerText = (i + 1);
    slotDiv.appendChild(label);
    hotbar.appendChild(slotDiv);
    slots[i].element = slotDiv;
  }
}
function selectSlot(index) {
  for (let i=0; i<slots.length; i++) {
    slots[i].element.className = 'slot' + (i === index ? ' selected' : '');
  }
  selectedSlot = index;
}
createHotbar();

let playerHealth = 100;
const maxHealth = 100;

function updateHealthBar() {
  const healthPercent = (playerHealth / maxHealth) * 100;
  healthBar.style.width = healthPercent + '%';
  healthNumber.textContent = playerHealth.toFixed(0);
  if (healthPercent > 60) healthBar.style.backgroundColor = '#0f0';
  else if (healthPercent > 30) healthBar.style.backgroundColor = '#ffae00';
  else healthBar.style.backgroundColor = '#f00';
}
updateHealthBar();

let swinging = false;
let swingProgress = 0;
const swingDuration = 300;
let lastTime = performance.now();
let hitRegisteredThisSwing = false;

// Multiplayer variables
let multiplayer = false;
let remotePlayers = {}; // For visualising other players
let localPlayers = {}; // For multiple local players if needed (simulate multiplayer)
let playerIdCounter = 0;

document.getElementById('quickPlayBtn').onclick = () => {
  // Enable local multiplayer mode
  multiplayer = true;
  alert('Local multiplayer enabled! Use arrow keys / WASD to move multiple players.');
  // Add a second local player as demonstration
  addLocalPlayer();
  addRemotePlayer(); // Add a remote player NPC for fun
};

// Function to add local player (simulate multiple)
function addLocalPlayer() {
  const id = 'player' + (++playerIdCounter);
  const playerObject = createPlayerMesh(0x0000ff); // Blue color for local
  scene.add(playerObject);
  localPlayers[id] = {
    mesh: playerObject,
    position: playerObject.position,
    update: function() {
      // For local, position is directly controlled
    }
  };
}

// Function to add remote player (simulate other)
function addRemotePlayer() {
  const id = 'player' + (++playerIdCounter);
  const playerObject = createPlayerMesh(0x00ffff); // Cyan for remote
  scene.add(playerObject);
  remotePlayers[id] = {
    mesh: playerObject,
    position: playerObject.position,
    updateFromServer: function(data) {
      this.mesh.position.set(data.x, data.y, data.z);
    }
  };
}

// Function to create a simple player mesh
function createPlayerMesh(colorHex) {
  const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.8, 8);
  const material = new THREE.MeshStandardMaterial({ color: colorHex });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.castShadow = true;
  return mesh;
}

function init() {
  scene = new THREE.Scene();

  const loader = new THREE.CubeTextureLoader();
  const skyTexture = loader.load([
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg",
  ]);
  scene.background = skyTexture;

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.y = 1.6;

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const sun = new THREE.DirectionalLight(0xffffff, 1.3);
  sun.position.set(100, 200, 100);
  sun.castShadow = true;
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));

  const textureLoader = new THREE.TextureLoader();
  const grassTexture = textureLoader.load('data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQ...' /* truncated */);
  grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
  grassTexture.repeat.set(40, 40);
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(500, 500),
    new THREE.MeshStandardMaterial({map: grassTexture})
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Create NPC enemies
  enemies = [];
  function createEnemy(x, z) {
    const enemy = new THREE.Group();
    const torsoGeo = new THREE.BoxGeometry(0.5, 1, 0.3);
    const torsoMat = new THREE.MeshStandardMaterial({color: 0x00ff00});
    const torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 1;
    enemy.add(torso);
    const headGeo = new THREE.SphereGeometry(0.2, 8, 8);
    const headMat = new THREE.MeshStandardMaterial({color: 0x00cc00});
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.9;
    enemy.add(head);
    enemy.position.set(x, 0, z);
    enemy.castShadow = true;
    enemy.userData = {
      health: 100,
      hitsTaken: 0,
      speed: 1.5,
      damage: 10,
      attackRange: 1.5,
      alive: true,
      lastAttackTime: 0,
      attackCooldown: 1000,
      isFlashing: false,
      flashTimeout: null
    };
    scene.add(enemy);
    enemies.push(enemy);
  }
  createEnemy(5, -10);
  createEnemy(-5, -12);
  createEnemy(7, -15);

  controls = new THREE.PointerLockControls(camera, document.body);
  document.addEventListener('click', () => { controls.lock(); });

  // Knife mesh
  const knifeGeo = new THREE.BoxGeometry(0.1, 0.02, 0.5);
  const knifeMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
  window.knife = new THREE.Mesh(knifeGeo, knifeMat);
  knife.position.set(0, -0.2, -0.5);
  camera.add(knife);
  scene.add(camera);

  // Event listeners
  document.addEventListener("keydown", onKeyDown);
  document.addEventListener("keyup", onKeyUp);
  window.addEventListener("resize", onWindowResize);

  // Hotbar key bindings
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Digit1') selectSlot(0);
    if (e.code === 'Digit2') selectSlot(1);
    if (e.code === 'Digit3') selectSlot(2);
    if (e.code === 'Digit4') selectSlot(3);
    if (e.code === 'Digit5') selectSlot(4);
  });

  // Attack on mouse down
  document.addEventListener('mousedown', () => {
    if (selectedSlot === 0 && !swinging) {
      swinging = true;
      swingProgress = 0;
    }
  });
}

function onKeyDown(e) {
  if (e.code === "KeyW") moveForward = true;
  if (e.code === "KeyS") moveBackward = true;
  if (e.code === "KeyA") moveLeft = true;
  if (e.code === "KeyD") moveRight = true;
  if (e.code === "Space" && canJump) {
    velocity.y = 10;
    canJump = false;
  }
  if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
    isCrouching = true;
    camera.position.y = 0.9;
  }
}
function onKeyUp(e) {
  if (e.code === "KeyW") moveForward = false;
  if (e.code === "KeyS") moveBackward = false;
  if (e.code === "KeyA") moveLeft = false;
  if (e.code === "KeyD") moveRight = false;
  if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
    isCrouching = false;
    camera.position.y = 1.6;
  }
}

function flashEnemy(enemy) {
  if (enemy.userData.isFlashing) return;
  enemy.userData.isFlashing = true;
  const originalColors = [];
  enemy.children.forEach(child => {
    if(child.material) {
      originalColors.push(child.material.color.getHex());
      child.material.color.set(0xff0000);
    }
  });
  enemy.userData.flashTimeout = setTimeout(() => {
    enemy.children.forEach((child, i) => {
      if(child.material) {
        child.material.color.setHex(originalColors[i]);
      }
    });
    enemy.userData.isFlashing = false;
  }, 150);
}

function checkKnifeHit() {
  if (hitRegisteredThisSwing) return;
  const knifePos = new THREE.Vector3();
  knife.getWorldPosition(knifePos);
  const knifeDir = new THREE.Vector3(0, 0, -1);
  knifeDir.applyQuaternion(camera.quaternion);
  for (const enemy of enemies) {
    if (!enemy.userData.alive) continue;
    const enemyPos = enemy.position.clone();
    const dist = enemyPos.distanceTo(knifePos);
    if (dist < 2) {
      const toEnemy = enemyPos.clone().sub(knifePos).normalize();
      const angle = knifeDir.angleTo(toEnemy);
      if (angle < Math.PI / 4) {
        enemy.userData.health -= 20;
        enemy.userData.hitsTaken++;
        flashEnemy(enemy);
        if (enemy.userData.health <= 0 || enemy.userData.hitsTaken >= 5) {
          enemy.userData.alive = false;
          scene.remove(enemy);
        }
        hitRegisteredThisSwing = true;
        break;
      }
    }
  }
}

function enemyAttack(delta, now) {
  const playerPos = controls.getObject().position;
  for (const enemy of enemies) {
    if (!enemy.userData.alive) continue;
    const dir = playerPos.clone().sub(enemy.position).setY(0);
    const dist = dir.length();
    if (dist > enemy.userData.attackRange) {
      dir.normalize();
      enemy.position.add(dir.multiplyScalar(enemy.userData.speed * delta));
    } else {
      if (now - enemy.userData.lastAttackTime > enemy.userData.attackCooldown) {
        playerHealth -= enemy.userData.damage;
        if (playerHealth < 0) playerHealth = 0;
        updateHealthBar();
        enemy.userData.lastAttackTime = now;
        if (playerHealth === 0) {
          alert("You died!");
          window.location.reload();
        }
      }
    }
  }
}

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = (now - lastTime) / 1000;
  lastTime = now;

  velocity.x -= velocity.x * 10 * delta;
  velocity.z -= velocity.z * 10 * delta;
  velocity.y -= gravity * delta;

  direction.z = Number(moveForward) - Number(moveBackward);
  direction.x = Number(moveRight) - Number(moveLeft);
  direction.normalize();

  if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;
  if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;

  controls.moveRight(-velocity.x * delta);
  controls.moveForward(-velocity.z * delta);

  camera.position.y += velocity.y * delta;
  if (camera.position.y < (isCrouching ? 0.9 : 1.6)) {
    velocity.y = 0;
    camera.position.y = (isCrouching ? 0.9 : 1.6);
    canJump = true;
  }

  if (swinging) {
    swingProgress += delta * (1000 / swingDuration);
    if (swingProgress >= 1) {
      swinging = false;
      swingProgress = 0;
      knife.rotation.z = 0;
      hitRegisteredThisSwing = false;
    } else {
      const angle = Math.sin(swingProgress * Math.PI) * -Math.PI / 2;
      knife.rotation.z = angle;
      if (swingProgress > 0.4 && swingProgress < 0.6) checkKnifeHit();
    }
  }

  enemyAttack(delta, now);

  // In local multiplayer, update remote players' positions as well
  if (multiplayer) {
    // For demonstration, move remote players randomly
    Object.values(remotePlayers).forEach(rp => {
      // simulate remote movement
      rp.mesh.position.x += (Math.random() - 0.5) * 0.01;
      rp.mesh.position.z += (Math.random() - 0.5) * 0.01;
    });
  }

  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Helper to create a player (either local or remote)
function createPlayerMesh(colorHex) {
  const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.8, 8);
  const material = new THREE.MeshStandardMaterial({ color: colorHex });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.castShadow = true;
  return mesh;
}

let enemies = [];
let sceneObjects = []; // For all scene objects for easy management

// Initialize scene
init();
animate();

</script>
</body>
</html>
