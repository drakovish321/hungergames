<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FPS Scene with Knife, Enemies & Health</title>
<style>
  body { margin: 0; overflow: hidden; background: black; cursor: none; }
  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px; height: 20px;
    margin-left: -10px; margin-top: -10px;
    pointer-events: none;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: white;
  }
  #crosshair:before { width: 2px; height: 20px; left: 9px; top: 0; }
  #crosshair:after { width: 20px; height: 2px; top: 9px; left: 0; }
  #hotbar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 10;
  }
  .slot {
    width: 50px; height: 50px;
    background: rgba(50,50,50,0.7);
    border: 2px solid #fff;
    display: flex; align-items: center; justify-content: center;
    font-family: sans-serif;
    font-size: 14px; color: #fff;
    position: relative;
    cursor: pointer;
  }
  .slot.selected { border-color: yellow; }
  .slot-label {
    position: absolute;
    top: -20px; width: 100%;
    text-align: center;
    font-family: sans-serif; font-size: 14px;
    color: white;
  }
  #healthBarContainer {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 220px;
    height: 25px;
    background: #555;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: 0 0 10px #000;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 5px;
    color: white;
    font-family: monospace;
    font-weight: bold;
    font-size: 18px;
  }
  #healthBar {
    height: 100%;
    width: 100%;
    background: #0f0;
    transition: width 0.3s ease, background-color 0.3s ease;
    flex-grow: 1;
    border-radius: 3px;
  }
  #quickPlayBtn {
    position: fixed; top: 20px; right: 20px;
    padding: 10px 20px; background: #222; color: #fff; border: none; cursor: pointer; z-index: 20;
  }
</style>
</head>
<body>
<button id="quickPlayBtn">Quick Play</button>
<div id="crosshair"></div>
<div id="hotbar"></div>
<div id="healthBarContainer">
  <div id="healthBar"></div>
  <div id="healthNumber">100</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

<script>
let scene, camera, renderer, controls;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let canJump = false;
let isCrouching = false;
const gravity = 30;

const hotbar = document.getElementById('hotbar');
const healthBar = document.getElementById('healthBar');
const healthNumber = document.getElementById('healthNumber');
const quickPlayBtn = document.getElementById('quickPlayBtn');

const slots = [
  { name: 'Knife', item: 'ðŸ”ª' },
  { name: 'Empty', item: '' },
  { name: 'Empty', item: '' },
  { name: 'Empty', item: '' },
  { name: 'Empty', item: '' },
];
let selectedSlot = 0;

function createHotbar() {
  hotbar.innerHTML = '';
  for (let i=0; i<slots.length; i++) {
    const slotDiv = document.createElement('div');
    slotDiv.className = 'slot' + (i === selectedSlot ? ' selected' : '');
    slotDiv.innerHTML = slots[i].item;
    slotDiv.onclick = () => { selectSlot(i); };
    const label = document.createElement('div');
    label.className = 'slot-label';
    label.innerText = (i + 1);
    slotDiv.appendChild(label);
    hotbar.appendChild(slotDiv);
    slots[i].element = slotDiv;
  }
}
function selectSlot(index) {
  for (let i=0; i<slots.length; i++) {
    slots[i].element.className = 'slot' + (i === index ? ' selected' : '');
  }
  selectedSlot = index;
}
createHotbar();

let playerHealth = 100;
const maxHealth = 100;

function updateHealthBar() {
  const healthPercent = (playerHealth / maxHealth) * 100;
  healthBar.style.width = healthPercent + '%';
  healthNumber.textContent = playerHealth.toFixed(0);
  if (healthPercent > 60) healthBar.style.backgroundColor = '#0f0';
  else if (healthPercent > 30) healthBar.style.backgroundColor = '#ffae00';
  else healthBar.style.backgroundColor = '#f00';
}
updateHealthBar();

let swinging = false;
let swingProgress = 0;
const swingDuration = 300;
let lastTime = performance.now();
let hitRegisteredThisSwing = false;

// WebSocket setup
let socket = null;
let multiplayerMode = false;
const serverUrl = 'ws://' + window.location.hostname + ':3000';
let yourId = null;
const remotePlayers = {};

document.getElementById('quickPlayBtn').onclick = () => {
  if (!multiplayerMode) {
    setupWebSocket();
  }
  multiplayerMode = true;
  alert('Switched to multiplayer mode!');
};

function setupWebSocket() {
  socket = new WebSocket(serverUrl);
  socket.onopen = () => { console.log('Connected to server'); };
  socket.onmessage = (msg) => {
    const data = JSON.parse(msg.data);
    handleServerMessage(data);
  };
  socket.onclose = () => { console.log('Disconnected from server'); };
}

function handleServerMessage(data) {
  if (data.type === 'assign_id') {
    yourId = data.id;
  } else if (data.type === 'player_join') {
    if (multiplayerMode && data.id !== yourId) {
      addRemotePlayer(data.id);
    }
  } else if (data.type === 'player_leave') {
    removeRemotePlayer(data.id);
  } else if (data.type === 'player_update') {
    const id = data.id;
    if (id !== yourId && remotePlayers[id]) {
      remotePlayers[id].updateFromServer(data.data);
    }
  } else if (data.type === 'attack') {
    const attackerId = data.id;
    if (attackerId !== yourId && remotePlayers[attackerId]) {
      const attacker = remotePlayers[attackerId];
      const dist = controls.getObject().position.distanceTo(attacker.position);
      if (dist < 2) {
        playerHealth -= 20;
        if (playerHealth < 0) playerHealth = 0;
        updateHealthBar();
        if (playerHealth === 0) {
          alert("You died!");
          window.location.reload();
        }
      }
    }
  }
}

function addRemotePlayer(id) {
  remotePlayers[id] = {
    position: new THREE.Vector3(),
    updateFromServer: function(data) {
      this.position.set(data.position.x, data.position.y, data.position.z);
    }
  };
}

function removeRemotePlayer(id) {
  delete remotePlayers[id];
}

// Send player position/health periodically
setInterval(() => {
  if (socket && socket.readyState === WebSocket.OPEN && yourId) {
    const pos = controls.getObject().position;
    socket.send(JSON.stringify({
      type: 'player_update',
      data: {
        position: { x: pos.x, y: pos.y, z: pos.z },
        health: playerHealth,
      }
    }));
  }
}, 100);

function init() {
  scene = new THREE.Scene();

  const loader = new THREE.CubeTextureLoader();
  const skyTexture = loader.load([
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg",
    "https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg",
  ]);
  scene.background = skyTexture;

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.y = 1.6;

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const sun = new THREE.DirectionalLight(0xffffff, 1.3);
  sun.position.set(100, 200, 100);
  sun.castShadow = true;
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));

  const textureLoader = new THREE.TextureLoader();
  const grassTexture = textureLoader.load('ddata:image/jpeg;base64,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'); // Your grass texture base64
  grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
  grassTexture.repeat.set(40, 40);
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(500, 500),
    new THREE.MeshStandardMaterial({map: grassTexture})
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  enemies = [];

  function createEnemy(x, z) {
    const enemy = new THREE.Group();
    const torsoGeo = new THREE.BoxGeometry(0.5, 1, 0.3);
    const torsoMat = new THREE.MeshStandardMaterial({color: 0x00ff00});
    const torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 1;
    enemy.add(torso);
    const headGeo = new THREE.SphereGeometry(0.2, 8, 8);
    const headMat = new THREE.MeshStandardMaterial({color: 0x00cc00});
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.9;
    enemy.add(head);
    enemy.position.set(x, 0, z);
    enemy.castShadow = true;
    enemy.userData = {
      health: 100,
      hitsTaken: 0,
      speed: 1.5,
      damage: 10,
      attackRange: 1.5,
      alive: true,
      lastAttackTime: 0,
      attackCooldown: 1000,
      isFlashing: false,
      flashTimeout: null
    };
    scene.add(enemy);
    enemies.push(enemy);
  }

  createEnemy(5, -10);
  createEnemy(-5, -12);
  createEnemy(7, -15);

  controls = new THREE.PointerLockControls(camera, document.body);
  document.addEventListener('click', () => {
    controls.lock();
  });

  const knifeGeo = new THREE.BoxGeometry(0.1, 0.02, 0.5);
  const knifeMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
  knife = new THREE.Mesh(knifeGeo, knifeMat);
  knife.position.set(0, -0.2, -0.5);
  camera.add(knife);
  scene.add(camera);

  document.addEventListener("keydown", onKeyDown);
  document.addEventListener("keyup", onKeyUp);
  window.addEventListener("resize", onWindowResize);

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Digit1') selectSlot(0);
    if (e.code === 'Digit2') selectSlot(1);
    if (e.code === 'Digit3') selectSlot(2);
    if (e.code === 'Digit4') selectSlot(3);
    if (e.code === 'Digit5') selectSlot(4);
  });

  document.addEventListener('mousedown', () => {
    if (selectedSlot === 0 && !swinging) {
      swinging = true;
      swingProgress = 0;
      if (multiplayerMode && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'attack' }));
      }
    }
  });
}

function onKeyDown(e) {
  if (e.code === "KeyW") moveForward = true;
  if (e.code === "KeyS") moveBackward = true;
  if (e.code === "KeyA") moveLeft = true;
  if (e.code === "KeyD") moveRight = true;
  if (e.code === "Space" && canJump) {
    velocity.y = 10;
    canJump = false;
  }
  if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
    isCrouching = true;
    camera.position.y = 0.9;
  }
}
function onKeyUp(e) {
  if (e.code === "KeyW") moveForward = false;
  if (e.code === "KeyS") moveBackward = false;
  if (e.code === "KeyA") moveLeft = false;
  if (e.code === "KeyD") moveRight = false;
  if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
    isCrouching = false;
    camera.position.y = 1.6;
  }
}

function flashEnemy(enemy) {
  if (enemy.userData.isFlashing) return;
  enemy.userData.isFlashing = true;
  const originalColors = [];
  enemy.children.forEach(child => {
    if(child.material) {
      originalColors.push(child.material.color.getHex());
      child.material.color.set(0xff0000);
    }
  });
  enemy.userData.flashTimeout = setTimeout(() => {
    enemy.children.forEach((child, i) => {
      if(child.material) {
        child.material.color.setHex(originalColors[i]);
      }
    });
    enemy.userData.isFlashing = false;
  }, 150);
}

function checkKnifeHit() {
  if (hitRegisteredThisSwing) return;
  const knifePos = new THREE.Vector3();
  knife.getWorldPosition(knifePos);
  const knifeDir = new THREE.Vector3(0, 0, -1);
  knifeDir.applyQuaternion(camera.quaternion);
  for (const enemy of enemies) {
    if (!enemy.userData.alive) continue;
    const enemyPos = enemy.position.clone();
    const dist = enemyPos.distanceTo(knifePos);
    if (dist < 2) {
      const toEnemy = enemyPos.clone().sub(knifePos).normalize();
      const angle = knifeDir.angleTo(toEnemy);
      if (angle < Math.PI / 4) {
        enemy.userData.health -= 20;
        enemy.userData.hitsTaken++;
        flashEnemy(enemy);
        if (enemy.userData.health <= 0 || enemy.userData.hitsTaken >= 5) {
          enemy.userData.alive = false;
          scene.remove(enemy);
        }
        hitRegisteredThisSwing = true;
        break;
      }
    }
  }
}

function enemyAttack(delta, now) {
  const playerPos = controls.getObject().position;
  for (const enemy of enemies) {
    if (!enemy.userData.alive) continue;
    const dir = playerPos.clone().sub(enemy.position).setY(0);
    const dist = dir.length();
    if (dist > enemy.userData.attackRange) {
      dir.normalize();
      enemy.position.add(dir.multiplyScalar(enemy.userData.speed * delta));
    } else {
      if (now - enemy.userData.lastAttackTime > enemy.userData.attackCooldown) {
        playerHealth -= enemy.userData.damage;
        if (playerHealth < 0) playerHealth = 0;
        updateHealthBar();
        enemy.userData.lastAttackTime = now;
        if (playerHealth === 0) {
          alert("You died!");
          window.location.reload();
        }
      }
    }
  }
}

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = (now - lastTime) / 1000;
  lastTime = now;

  velocity.x -= velocity.x * 10 * delta;
  velocity.z -= velocity.z * 10 * delta;
  velocity.y -= gravity * delta;

  direction.z = Number(moveForward) - Number(moveBackward);
  direction.x = Number(moveRight) - Number(moveLeft);
  direction.normalize();

  if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;
  if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;

  controls.moveRight(-velocity.x * delta);
  controls.moveForward(-velocity.z * delta);

  camera.position.y += velocity.y * delta;
  if (camera.position.y < (isCrouching ? 0.9 : 1.6)) {
    velocity.y = 0;
    camera.position.y = (isCrouching ? 0.9 : 1.6);
    canJump = true;
  }

  if (swinging) {
    swingProgress += delta * (1000 / swingDuration);
    if (swingProgress >= 1) {
      swinging = false;
      swingProgress = 0;
      knife.rotation.z = 0;
      hitRegisteredThisSwing = false;
    } else {
      const angle = Math.sin(swingProgress * Math.PI) * -Math.PI / 2;
      knife.rotation.z = angle;
      if (swingProgress > 0.4 && swingProgress < 0.6) checkKnifeHit();
    }
  }

  enemyAttack(delta, now);

  // Send updates if in multiplayer
  if (multiplayerMode && socket && socket.readyState === WebSocket.OPEN && yourId) {
    const pos = controls.getObject().position;
    socket.send(JSON.stringify({
      type: 'player_update',
      data: {
        position: { x: pos.x, y: pos.y, z: pos.z },
        health: playerHealth,
      }
    }));
  }

  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Initialize everything
init();
animate();
</script>
</body>
</html>
