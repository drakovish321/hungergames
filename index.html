<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FPS Scene with Knife, Enemies & Health</title>
<style>
  body { margin: 0; overflow: hidden; background: black; cursor: none; }
  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px; height: 20px;
    margin-left: -10px; margin-top: -10px;
    pointer-events: none;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: white;
  }
  #crosshair:before { width: 2px; height: 20px; left: 9px; top: 0; }
  #crosshair:after { width: 20px; height: 2px; top: 9px; left: 0; }
  #hotbar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 10;
  }
  .slot {
    width: 50px; height: 50px;
    background: rgba(50,50,50,0.7);
    border: 2px solid #fff;
    display: flex; align-items: center; justify-content: center;
    font-family: sans-serif;
    font-size: 14px; color: #fff;
    position: relative;
    cursor: pointer;
  }
  .slot.selected { border-color: yellow; }
  .slot-label {
    position: absolute;
    top: -20px; width: 100%;
    text-align: center;
    font-family: sans-serif; font-size: 14px;
    color: white;
  }
  #healthBarContainer {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 220px;
    height: 25px;
    background: #555;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: 0 0 10px #000;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 5px;
    color: white;
    font-family: monospace;
    font-weight: bold;
    font-size: 18px;
  }
  #healthBar {
    height: 100%;
    width: 100%;
    background: #0f0;
    transition: width 0.3s ease, background-color 0.3s ease;
    flex-grow: 1;
    border-radius: 3px;
  }
  /* New styles for the menu overlay */
  #menuOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
    font-family: sans-serif;
    color: white;
  }
  #menuOverlay button {
    background: #222;
    border: 2px solid white;
    color: white;
    font-size: 24px;
    padding: 15px 40px;
    margin: 12px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.3s;
  }
  #menuOverlay button:hover {
    background: #555;
  }
  /* Player indicators */
  .player-label {
    position: absolute;
    color: white;
    font-weight: bold;
    font-family: monospace;
    pointer-events: none;
    user-select: none;
    text-shadow: 0 0 5px black;
    font-size: 14px;
  }
</style>
</head>
<body>

<div id="menuOverlay">
  <button id="mockingjayBtn">Mockingjay Mode</button>
  <button id="quickplayBtn">Quickplay</button>
</div>

<div id="crosshair" style="display:none;"></div>
<div id="hotbar" style="display:none;"></div>
<div id="healthBarContainer" style="display:none;">
  <div id="healthBar"></div>
  <div id="healthNumber">100</div>
</div>

<!-- Firebase SDK (modular) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import {
    getDatabase,
    ref,
    onValue,
    set,
    update,
    onDisconnect,
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyC7AS5TZTnjwDQlqJntJe2I5PcTuLO506E",
    authDomain: "hungergames-1f808.firebaseapp.com",
    databaseURL: "https://hungergames-1f808-default-rtdb.firebaseio.com",
    projectId: "hungergames-1f808",
    storageBucket: "hungergames-1f808.firebasestorage.app",
    messagingSenderId: "806026839452",
    appId: "1:806026839452:web:b73ae22cf3e750cfd53459",
    measurementId: "G-TGYV83N1CY",
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // --- Your existing FPS code variables ---
  let scene, camera, renderer, controls;
  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
  let velocity = new THREE.Vector3();
  let direction = new THREE.Vector3();
  let canJump = false;
  let isCrouching = false;
  const gravity = 30;

  const hotbar = document.getElementById('hotbar');
  const healthBar = document.getElementById('healthBar');
  const healthNumber = document.getElementById('healthNumber');

  const slots = [
    { name: 'Knife', item: 'ðŸ”ª' },
    { name: 'Empty', item: '' },
    { name: 'Empty', item: '' },
    { name: 'Empty', item: '' },
    { name: 'Empty', item: '' },
  ];
  let selectedSlot = 0;

  function createHotbar() {
    hotbar.innerHTML = '';
    for (let i=0; i<slots.length; i++) {
      const slotDiv = document.createElement('div');
      slotDiv.className = 'slot' + (i === selectedSlot ? ' selected' : '');
      slotDiv.innerHTML = slots[i].item;
      slotDiv.onclick = () => { selectSlot(i); };
      const label = document.createElement('div');
      label.className = 'slot-label';
      label.innerText = (i + 1);
      slotDiv.appendChild(label);
      hotbar.appendChild(slotDiv);
      slots[i].element = slotDiv;
    }
  }
  function selectSlot(index) {
    for (let i=0; i<slots.length; i++) {
      slots[i].element.className = 'slot' + (i === index ? ' selected' : '');
    }
    selectedSlot = index;
  }

  let playerHealth = 100;
  const maxHealth = 100;

  function updateHealthBar() {
    const healthPercent = (playerHealth / maxHealth) * 100;
    healthBar.style.width = healthPercent + '%';
    healthNumber.textContent = playerHealth.toFixed(0);
    if (healthPercent > 60) healthBar.style.backgroundColor = '#0f0';
    else if (healthPercent > 30) healthBar.style.backgroundColor = '#ffae00';
    else healthBar.style.backgroundColor = '#f00';
  }
  updateHealthBar();

  let swinging = false;
  let swingProgress = 0;
  const swingDuration = 300;

  let lastTime = performance.now();
  let hitRegisteredThisSwing = false;

  let playerSpeed = 400; // Default player speed

  // Firebase Multiplayer variables
  const playerId = Date.now().toString(); // Simple unique player ID
  const playerRef = ref(db, `players/${playerId}`);
  const playersRef = ref(db, 'players');

  // Store players' 3D objects and labels for rendering
  const otherPlayers = new Map();

  // Initialize player data in DB
  function joinGame() {
    set(playerRef, {
      x: 0,
      y: 0,
      z: 0,
      health: 100,
      attacking: false,
      lastAttackTime: 0,
    });
    onDisconnect(playerRef).remove();
  }

  // Update player position in DB
  function updatePosition(x, y, z) {
    update(playerRef, { x, y, z });
  }

  // Update attack status in DB
  function attack() {
    const now = Date.now();
    update(playerRef, {
      attacking: true,
      lastAttackTime: now,
    });
    setTimeout(() => {
      update(playerRef, { attacking: false });
    }, 500);
  }

  // Detect hits on other players
  function detectHits(players) {
    const myPlayer = players[playerId];
    if (!myPlayer || !myPlayer.attacking) return;

    Object.entries(players).forEach(([id, player]) => {
      if (id === playerId) return;
      const distance = Math.hypot(player.x - myPlayer.x, player.y - myPlayer.y, player.z - myPlayer.z);
      if (distance < 2) { // Close enough for a hit (adjusted for 3D)
        // Hit detected - reduce health
        const newHealth = Math.max((player.health || 100) - 10, 0);
        update(ref(db, `players/${id}`), { health: newHealth });
      }
    });
  }

  // Create 3D representation of other players
  function createOtherPlayerMesh(id) {
    const group = new THREE.Group();

    const torsoGeo = new THREE.BoxGeometry(0.5, 1, 0.3);
    const torsoMat = new THREE.MeshStandardMaterial({color: 0x0000ff});
    const torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 1;
    group.add(torso);

    const headGeo = new THREE.SphereGeometry(0.2, 8, 8);
    const headMat = new THREE.MeshStandardMaterial({color: 0x0000cc});
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.9;
    group.add(head);

    // Label
    const label = document.createElement('div');
    label.className = 'player-label';
    label.textContent = `Player ${id.slice(-4)}`;
    document.body.appendChild(label);

    group.userData = { labelElement: label };
    scene.add(group);
    return group;
  }

  function updateOtherPlayers(players) {
    // Remove players no longer present
    otherPlayers.forEach((mesh, id) => {
      if (!players[id]) {
        scene.remove(mesh);
        if (mesh.userData.labelElement) {
          document.body.removeChild(mesh.userData.labelElement);
        }
        otherPlayers.delete(id);
      }
    });

    Object.entries(players).forEach(([id, player]) => {
      if (id === playerId) return; // skip self

      let mesh = otherPlayers.get(id);
      if (!mesh) {
        mesh = createOtherPlayerMesh(id);
        otherPlayers.set(id, mesh);
      }
      mesh.position.set(player.x, player.y, player.z);

      // Update color based on health
      const healthPercent = (player.health || 100) / 100;
      mesh.children.forEach(child => {
        if (child.material) {
          child.material.color.setRGB(0, 0, healthPercent);
        }
      });

      // Position label on screen
      const vector = new THREE.Vector3(player.x, player.y + 2, player.z);
      vector.project(camera);
      const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
      const y = ( - vector.y * 0.5 + 0.5) * window.innerHeight;
      if (mesh.userData.labelElement) {
        mesh.userData.labelElement.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
        mesh.userData.labelElement.style.display = (vector.z < 1) ? 'block' : 'none';
      }
    });
  }

  // Your original enemy stuff (local NPCs)
  let enemies = [];
  let knife;

  function createEnemy(x, z) {
    const enemy = new THREE.Group();

    const torsoGeo = new THREE.BoxGeometry(0.5, 1, 0.3);
    const torsoMat = new THREE.MeshStandardMaterial({color: 0x00ff00});
    const torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 1;
    enemy.add(torso);

    const headGeo = new THREE.SphereGeometry(0.2, 8, 8);
    const headMat = new THREE.MeshStandardMaterial({color: 0x00cc00});
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.9;
    enemy.add(head);

    enemy.position.set(x, 0, z);
    enemy.castShadow = true;
    enemy.userData = {
      health: 100,
      hitsTaken: 0,
      speed: 1.5,
      damage: 10,
      attackRange: 1.5,
      alive: true,
      lastAttackTime: 0,
      attackCooldown: 1000,
      isFlashing: false,
      flashTimeout: null
    };

    scene.add(enemy);
    enemies.push(enemy);
  }

  // Flashing enemy on hit
  function flashEnemy(enemy) {
    if (enemy.userData.isFlashing) return;
    enemy.userData.isFlashing = true;
    const originalColors = [];
    enemy.children.forEach(child => {
      if(child.material) {
        originalColors.push(child.material.color.getHex());
        child.material.color.set(0xff0000);
      }
    });
    enemy.userData.flashTimeout = setTimeout(() => {
      enemy.children.forEach((child, i) => {
        if(child.material) {
          child.material.color.setHex(originalColors[i]);
        }
      });
      enemy.userData.isFlashing = false;
    }, 150);
  }

  function checkKnifeHit() {
    if (hitRegisteredThisSwing) return;

    const knifePos = new THREE.Vector3();
    knife.getWorldPosition(knifePos);

    const knifeDir = new THREE.Vector3(0, 0, -1);
    knifeDir.applyQuaternion(camera.quaternion);

    // Check local enemies
    for (const enemy of enemies) {
      if (!enemy.userData.alive) continue;

      const enemyPos = enemy.position.clone();
      const dist = enemyPos.distanceTo(knifePos);

      if (dist < 2) {
        const toEnemy = enemyPos.clone().sub(knifePos).normalize();
        const angle = knifeDir.angleTo(toEnemy);
        if (angle < Math.PI / 4) {
          enemy.userData.health -= 20;
          enemy.userData.hitsTaken++;
          flashEnemy(enemy);

          if (enemy.userData.health <= 0 || enemy.userData.hitsTaken >= 5) {
            enemy.userData.alive = false;
            scene.remove(enemy);
          }

          hitRegisteredThisSwing = true;
          break;
        }
      }
    }

    // Check other players for hit detection (send attack event)
    const now = Date.now();
    // Only attack if knife selected and swing phase allows it
    if (selectedSlot === 0) {
      attack(); // Update attack state in DB for hit detection by others
    }
  }

  function enemyAttack(delta, now) {
    const playerPos = controls.getObject().position;

    for (const enemy of enemies) {
      if (!enemy.userData.alive) continue;

      const dir = playerPos.clone().sub(enemy.position).setY(0);
      const dist = dir.length();

      if (dist > enemy.userData.attackRange) {
        dir.normalize();
        enemy.position.add(dir.multiplyScalar(enemy.userData.speed * delta));
      } else {
        if (now - enemy.userData.lastAttackTime > enemy.userData.attackCooldown) {
          playerHealth -= enemy.userData.damage;
          if (playerHealth < 0) playerHealth = 0;
          updateHealthBar();
          enemy.userData.lastAttackTime = now;
          if (playerHealth === 0) {
            alert("You died!");
            window.location.reload();
          }
        }
      }
    }
  }

  let gameStarted = false;

  function init() {
    scene = new THREE.Scene();

    const loader = new THREE.CubeTextureLoader();
    const skyTexture = loader.load([
      "https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg",
      "https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg",
      "https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg",
      "https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg",
      "https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg",
      "https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg",
    ]);
    scene.background = skyTexture;

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.y = 1.6;

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const sun = new THREE.DirectionalLight(0xffffff, 1.3);
    sun.position.set(100, 200, 100);
    sun.castShadow = true;
    scene.add(sun);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    const textureLoader = new THREE.TextureLoader();
    const grassTexture = textureLoader.load('data:image/jpeg;base64,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');
    grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.repeat.set(40, 40);
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(500, 500),
      new THREE.MeshStandardMaterial({map: grassTexture})
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    enemies = [];

    createEnemy(5, -10);
    createEnemy(-5, -12);
    createEnemy(7, -15);

    controls = new THREE.PointerLockControls(camera, document.body);

    document.addEventListener('click', () => {
      if (controls.isLocked === false && gameStarted) {
        controls.lock();
      }
    });

    const knifeGeo = new THREE.BoxGeometry(0.1, 0.02, 0.5);
    const knifeMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
    knife = new THREE.Mesh(knifeGeo, knifeMat);
    knife.position.set(0, -0.2, -0.5);
    camera.add(knife);
    scene.add(camera);

    document.addEventListener("keydown", onKeyDown);
    document.addEventListener("keyup", onKeyUp);
    window.addEventListener("resize", onWindowResize);

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Digit1') selectSlot(0);
      if (e.code === 'Digit2') selectSlot(1);
      if (e.code === 'Digit3') selectSlot(2);
      if (e.code === 'Digit4') selectSlot(3);
      if (e.code === 'Digit5') selectSlot(4);
    });

    window.addEventListener('mousedown', () => {
      if (selectedSlot === 0 && !swinging && gameStarted) {
        swinging = true;
        swingProgress = 0;
      }
    });

    // Join multiplayer game
    joinGame();

    // Listen for all players updates
    onValue(playersRef, (snapshot) => {
      const players = snapshot.val() || {};

      // Update other players 3D meshes and labels
      updateOtherPlayers(players);

      // Detect hits on others if attacking
      detectHits(players);

      // Update local player health from DB in case hit by others
      if (players[playerId]) {
        const dbHealth = players[playerId].health;
        if (typeof dbHealth === 'number' && dbHealth !== playerHealth) {
          playerHealth = dbHealth;
          updateHealthBar();
          if (playerHealth <= 0) {
            alert("You died!");
            window.location.reload();
          }
        }
      }
    });
  }

  function onKeyDown(e) {
    if (!gameStarted) return;
    if (e.code === "KeyW") moveForward = true;
    if (e.code === "KeyS") moveBackward = true;
    if (e.code === "KeyA") moveLeft = true;
    if (e.code === "KeyD") moveRight = true;
    if (e.code === "Space" && canJump) {
      velocity.y = 10;
      canJump = false;
    }
    if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
      isCrouching = true;
      camera.position.y = 0.9;
    }
  }
  function onKeyUp(e) {
    if (!gameStarted) return;
    if (e.code === "KeyW") moveForward = false;
    if (e.code === "KeyS") moveBackward = false;
    if (e.code === "KeyA") moveLeft = false;
    if (e.code === "KeyD") moveRight = false;
    if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
      isCrouching = false;
      camera.position.y = 1.6;
    }
  }

  function animate() {
    requestAnimationFrame(animate);

    if (!gameStarted) return;

    const now = performance.now();
    const delta = (now - lastTime) / 1000;
    lastTime = now;

    velocity.x -= velocity.x * 10 * delta;
    velocity.z -= velocity.z * 10 * delta;
    velocity.y -= gravity * delta;

    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize();

    if (moveForward || moveBackward) velocity.z -= direction.z * playerSpeed * delta;
    if (moveLeft || moveRight) velocity.x -= direction.x * playerSpeed * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);

    camera.position.y += velocity.y * delta;
    if (camera.position.y < (isCrouching ? 0.9 : 1.6)) {
      velocity.y = 0;
      camera.position.y = (isCrouching ? 0.9 : 1.6);
      canJump = true;
    }

    // Update player position in DB
    const pos = controls.getObject().position;
    updatePosition(pos.x, pos.y, pos.z);

    if (swinging) {
      swingProgress += delta * (1000 / swingDuration);
      if (swingProgress >= 1) {
        swinging = false;
        swingProgress = 0;
        knife.rotation.z = 0;
        hitRegisteredThisSwing = false;
      } else {
        const angle = Math.sin(swingProgress * Math.PI) * -Math.PI / 2;
        knife.rotation.z = angle;

        if (swingProgress > 0.4 && swingProgress < 0.6) checkKnifeHit();
      }
    }

    enemyAttack(delta, now);

    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Button event listeners
  document.getElementById('mockingjayBtn').addEventListener('click', () => {
    startGame(true);
  });
  document.getElementById('quickplayBtn').addEventListener('click', () => {
    startGame(false);
  });

  function startGame(mockingjayMode) {
    document.getElementById('menuOverlay').style.display = 'none';
    document.getElementById('crosshair').style.display = 'block';
    hotbar.style.display = 'flex';
    document.getElementById('healthBarContainer').style.display = 'flex';
    createHotbar();
    if (mockingjayMode) {
      playerSpeed = 300; // slower speed for Mockingjay Mode
    } else {
      playerSpeed = 400; // default speed
    }
    gameStarted = true;
    init();
    animate();
  }
</script>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

</body>
</html>
